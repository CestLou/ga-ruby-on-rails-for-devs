Live Rails MVC Application from Scratch
=======================================

Start with the skeleton built in [a previous lesson](7-rails-basics.md).

* *Gemfile*: gems, including Rails
* *config.ru*: rack-based startup script
* *script/rails*: rails-based startup script
* *config/routes.rb*: drawn routes
* *config/environment.rb*: application initialization
* *config/boot.rb*: application boot
* *config/application.rb*: application
* *config/initializers/secret_token.rb*: base cryptographic blob
* *public/index.html*: hello world

Rakefile
--------

Tasks, such as database migrations, are written in [Rake](https://github.com/jimweirich/rake). Rake needs a `Rakefile`.

    require File.expand_path('../config/application', __FILE__)

    require 'rake'

    RailsMVC::Application.load_tasks

You can run `rake -T` to see available tasks.

Asset Pipeline
--------------

There're many templating languages that can be used with Rails. ERB is the default. Lets add an application layout in HAML instead. Add `haml-rails` to Gemfile and `app/views/layouts/application.html.haml`.

    !!!
    %html
      %head
        %title
          Rails MVC
        = stylesheet_link_tag "application"
        = javascript_include_tag "application"

      %body
        = yield

For the stylesheet and javascript links to work, enable the application pipeline in `config/application.rb`.

    # Enable the asset pipeline
    config.assets.enabled = true

Enable post-backs with JQuery by adding `jquery-rails` to Gemfile and by including JQuery in `app/assets/javascripts/application.js`.

    //= require jquery
    //= require jquery_ujs
    //= require_tree .

Add a stylesheet to `app/assets/stylesheets/application.css.scss`.

Database Configuration
----------------------

The configuration file for the database is authored in *YAML*, `config/database.yml`.

    common: &common
      adapter: postgresql
      username: rails
      password: password

    development:
      <<: *common
      database: rails_development

    test:
      <<: *common
      database: rails_test

    production:
      <<: *common
      database: rails_production

*Exercise*: create a Rake task in `lib/tasks` that loads this file and displays the configuration for the current environment. Make sure the `database` value is set - you may need to set `YAML::ENGINE.yamler = 'syck'`.

If you run `rake -T` you'll notice that there're no database tasks. That's because we're only using the *action_controller* part of Rails. Change `require "action_controller/railtie"` in `config/application.rb`.

    require 'rails/all'

Re-run `rake -T`.

Database Migrations
-------------------

Since we're building a database-backed application, we need a schema. We could create `db/schema.rb` and populate it with a schema, but the Rails way is to use *database migrations* as it supports both creating a new database and upgrading an existing one.

Create `db/migrate/1_create_things.rb`.

    class CreateThings < ActiveRecord::Migration
      def change
        create_table :things do |t|
          t.string :name
          t.string :description
          t.timestamps
        end
      end
    end
 
Gemfile
-------

Finally, we need a Postgresql driver in `Gemfile`.

    gem "pg"

Local Database
--------------

We're ready to create the database.

    rake db:create
    rake db:migrate

Data Model
----------

Create `app/models/thing.rb`.

    class Thing < ActiveRecord::Base
      validates_presence_of :name
      validates_uniqueness_of :name
    end

The validators are a way to ensure presence and uniqueness of fields. The fields are automagically generated by examining the schema on application startup.

Application Controller
----------------------

    class ApplicationController < ActionController::Base
    end

Things Controller
-----------------

    class ThingsController < ApplicationController
    end

Retrieving all things.

    def index
      @things = Thing.all
    end

Retrieve an existing thing by parameter.

    def show
      @thing = Thing.find(params[:id])
    end

Create a new thing.

    def new
      @thing = Thing.new
    end

Persist a new or update an existing thing.

    def create
      @thing = Thing.new(params[:thing])
      if @thing.save
        redirect_to @thing, notice: 'Thing was successfully created.'
      else
        render action: "new"
      end
    end

    def update
      @thing = Thing.find(params[:id])
      if @thing.update_attributes(params[:thing])
        redirect_to @thing, notice: 'Thing was successfully updated.'
      else
        render action: "edit"
      end
    end

Things View
-----------

Add `app/views/things/index.html.haml`.

    %h1 Things

    %table
      %tr
        %th= "Name"
        %th

      - @things.each do |thing|
        = thing.name

We can use `simple_form` to make an edit form partial.

    = simple_form_for @thing do |f|
      = render 'shared/error_msg', model: @thing
      = f.input :name
      = f.button :submit

The shared error message is a generic way of yielding problems in `views/shared/_error_msg.html.haml`.

    - if model.errors.any?
      .error_explanation
        %h3= "#{pluralize(model.errors.count, "error")} saving #{model.class}:"
        %ul
          - model.errors.full_messages.each do |msg|
            %li= msg

The form can be used for the new thing in `app/views/things/new.html.haml`.

    %h1 New Thing

    = render 'form'

    = link_to 'Back', things_path

It can also be used to edit a thing in `app/views/things/edit.html.haml`.

    %h1= @thing.name

    = render 'form'

    = link_to 'Back', things_path

Finally, we should display a thing in `app/views/things/show.html.haml`.

    %ul
      %li= "Name: #{@thing.name}"

    = link_to 'Edit', edit_thing_path(@thing)
    |
    = link_to 'Back', things_path

Things Routes
-------------

Edit `config/routes.rb`.

    RailsMVC::Application.routes.draw do
      resources :things
    end

Review `rake routes`.



