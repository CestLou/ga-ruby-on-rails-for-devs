Los objetos de Ruby
===================

Clase básica
------------

Todas las clases heredan de la clase `Object`. También puedes heredar de otra clase.

``` ruby
class Color
  def initialize(name = nil)
    @name = name
  end
  def name=(value)
    @name = value
  end
  def name
    @name
  end
end
```

Las instancias pueden crearse con `new` y son recogidas por el garbage collector (recolector de basura).

``` ruby
puts Color.new.inspect # <Color: @name=nil>
puts Color.new("red").inspect # <Color: @name="red">
```

Excepciones
-----------

Las excepciones pueden ser de tipo `RuntimeError < StandardError < Exception`. El atajo `raise 'error!'` produce un `RuntimeError`.

``` ruby
begin
  raise "error!"
rescue Exception => e
  puts e.inspect # #<RuntimeError: error!>
end
```

Las excepciones pueden ser atrapadas para luego realizar un nuevo intento.

``` ruby
count = 1
begin
  raise BadError.new("error!") if count <= 2
rescue Exception => e
  count += 1
  puts e.inspect # #<BadError: error!> (twice)
  retry
end
```

Mixins
------

Puedes mezclar métodos de instancia dentro de otras clases con `include`.

``` ruby
module Incrementable
  def increment
    self.to_i + 1
  end
end

module Decrementable
  def decrement
    self.to_i - 1
  end
end

class Number
  include Incrementable
  include Decrementable

  attr_reader :value

  def initialize(value)
    @value = value
  end

  def to_i
    @value.to_i
  end

end

n = Number.new(5)
puts n.increment # 6
puts n.decrement # 4
```

Este opción de mixins promueve la composición sobre la herencia.

Monkey Patching
---------------

Los métodos, las clases, las variables y todo lo demás es definido cuando es inicializado. Puede realizar un *monkey-patch* a cualquier clase en Ruby.

``` ruby
class Number
  def to_i
    @value.to_i + 10
  end
end

puts n.increment # 16
puts n.decrement # 14
```

Un gran poder conlleva una gran responsabilidad.

Reflexión
---------

La reflexión está incorporada y los métodos pueden y son comúnmente definidos como runtimes. También puedes o bien realizar un monkey-patch a una clase o abrirla y trabajar con cualquier declaración de privacidad.

``` ruby
Color.methods
Color.new.methods

# Color.define_method :shine, lambda { "shiny #{name}" } - illegal, define_method is private
Color.send(:define_method, :shine, lambda { "shiny #{name}" })
puts Color.new("red").shine # shiny red

Color.new.is_a?(Color) # true
```

Ejercicio
---------

Agregue un método llamado `distancia_euclidiana_cuadrada` a la clase `Hash` que tome otra clase `Hash` como parámetro y calcule la distancia euclidiana cuadrada entre ellas. La distancia euclidiana cuadrada entre `{ :x => 1, :y => 2 }` y `{ :x => 3, :y => 4 }` es `(1 - 3)**2 + (2 - 4)**2`.

``` ruby
puts ( {}.distancia_euclidiana_cuadrada({}) ) # 0
puts ( { :x => 2, :y => 3 }.distancia_euclidiana_cuadrada({ :y => 4, :x => 5 }) ) # 10
puts ( { :x => 10, :y => 20 }.distancia_euclidiana_cuadrada({}) ) # 500
puts ( {}.distancia_euclidiana_cuadrada({ :x => 10, :y => 20 }) ) # 500
```

