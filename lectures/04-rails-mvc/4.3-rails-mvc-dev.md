Aplicación Rails MVC desde Cero
================================

Comience con el esqueleto construido en la [lección previa](7-rails-basics.md); nombre al módulo de la aplicación *RailsMVC*.

* *Gemfile*: gemas, incluyendo a Rails
* *config.ru*: script de arranque de tipo Rack
* *script/rails*: script de arranque de tipo Rails
* *config/environment.rb*: inicialización de la aplicación
* *config/boot.rb*: buteo de la aplicación
* *config/application.rb*: aplicación
* *config/initializers/secret_token.rb*: blob criptográfico base
* *public/index.html*: hola mundo

Rutas
-----

Una ruta conecta una solicitud con el controlador. Las rutas son declaradas en *config/routes.rb*.

``` ruby
RailsMVC::Application.routes.draw do
  # routes declared here
end
```

El ruteo por defecto es *RESTful* y utiliza los clásicos (*GET*, *PUT*, *POST* and *DELETE*) con las conocidas acciones de recursos (`:index`, `:show`, `:new`, `:edit`, `:update` y `:destroy`).

Rakefile
--------

Las tareas, tal como la migración de la base de datos, son escritas en [Rake](https://github.com/jimweirich/rake). Rake necesita el archivo *Rakefile*, el cual importa el código de la aplicación. Además tienes acceso a todos los modelos del dominio en las tareas de Rake.

``` ruby
require File.expand_path('../config/application', __FILE__)

require 'rake'

RailsMVC::Application.load_tasks
```

Puedes ejecutar `rake -T` para ver todas las tareas disponibles.

    $ rake -T
    rake about # List versions of all Rails frameworks and the environment
    ...

La carpeta de la aplicación
---------------------------

Por convención el código de la aplicación está ubicado en *app*.

Asset Pipeline
--------------

El *asset pipeline* autoriza a los JavaScript, los CSS y otros objetos estáticos y los compila o empaqueta para la aplicación. Por ejemplo, en Rails 3.1 el asset pipeline habilita a los desarrolladores a escribir con CoffeeScript en lugar de JavaScript.

Habilite el pipeline de la aplicación en *config/application.rb*.

    # Enable the asset pipeline
    config.assets.enabled = true

El HTML dinámico en Rails es mostrado con *templates*. Los templates pueden ser creados en muchos lenguajes y ejecutar código de Ruby. Rails utiliza *ERB* por defecto. Otro creador de templates popular es *HAML*. Agregue `haml-rails` a la Gemfile y un layout *app/views/layouts/application.html.haml*. Un layout es un template en una capa superior que define la estructura de la página, incluyendo la hoja de estilo y los javascripts.

``` haml
!!!
%html
  %head
    %title
      Rails MVC
    = stylesheet_link_tag "application"
    = javascript_include_tag "application"

  %body
    = yield
```

Los métodos `stylesheet_link_tag` y `javascript_include_tag` son declarados en [ActionView::Helpers::AssetTagHelper](http://api.rubyonrails.org/classes/ActionView/Helpers/AssetTagHelper.html), la cual es la punta del *asset pipeline*. A pesar de poder definir manualmente los vínculos en tu template, esas funciones trabajan con el concepto de asset pipeline y te permiten agregar configuraciones globales, tal como *asset host* para assets ubicados externamente en un CDN. Es bastante común para las aplicaciones en Rails generar assets en tiempo de desarrollo y luego realizar su deploy a un servidor web. 

Los asset pipeline tienen el concepto de *archivo manifiesto* el cual incluye las *directivas* para dejarle saber a Rails qué archivos incluir. Cree *app/assets/javascripts/application.js* - uno de esos *archivos manifiesto* con las siguientes *directivas*.

    //= require jquery
    //= require jquery_ujs
    //= require_tree .

Rails ahora utiliza jQuery. Agregue `jquery-rails` a su Gemfile.

Agregue una hoja de estilo *app/assets/stylesheets/application.css.scss*. La hoja de estilo es creada con SCSS la cual es una extensión de CSS, que utiliza variables, reglas anidadas, mixins, importaciones en línea, etc.

``` css
#error_explanation {
  background-color: #f0f0f0;
  h2 {
    background-color: #c00;
    color: #fff; 
  }
  ul li {
    font-size: 12px;
    list-style: square; 
  } 
}
```

Configuración de la base de datos
---------------------------------

Ya que estamos usando PostgreSQL, vamos a necesitar `pg` en la Gemfile.

Los archivos de configuración de Rails son creados con *YAML*, el cual ejecuta código Ruby. Puede, por ejemplo, referenciar a variables de entorno con `ENV['VARIABLE']`. Agregue *config/database.yml* para la configuración de la base de datos. Puedes reutilizar bloques de configuración con `<<:`.

``` yaml
common: &common
  adapter: postgresql
  username: rails
  password: password
  host: localhost
  port: 5432

development:
  <<: *common
  database: rails_development

test:
  <<: *common
  database: rails_test

production:
  <<: *common
  database: rails_production
```

Si ejecutas `rake -T` serás notificado de que no existen tareas para la base de datos. Estos es porque estás utilizando solamente el *action_controller* de Rails. Modifique `require "action_controller/railtie"` en *config/application.rb* incluyendo `rails/all`.

``` ruby
require 'rails/all'
```

Ejecute nuevamente `rake -T` y asegúrese que las tareas de la base de datos ahora son mostradas.

Migración de base de datos
--------------------------

Una aplicación con una base de datos de respaldo necesita de un esqueleto. Podríamos crearlo en *db/schema.rb* y completarlo con el esqueleto, pero la forma en que lo realiza Rails es utilizando *migración de base de datos*. La migración soporta la creación de una nueva base de datos y la actualización de una ya existente mediante la utilización de un sistema de versiones de bases de datos integrado.

Cree *db/migrate/1_create_things.rb*.

``` ruby
class CreateThings < ActiveRecord::Migration
  def change
    create_table :things do |t|
      t.string :name
      t.timestamps
    end
  end
end
```

Olvidamos la descripción. Vamos a crear otra migración para agregársela.

    $ rails generate migration add_description_to_things description:string

      invoke  active_record
      create    db/migrate/20111207001110_add_description_to_things.rb

Esto debería generar el siguiente archivo de migración:

``` ruby
class AddDescriptionToThings < ActiveRecord::Migration
  def change
    add_column :things, :description, :string
  end
end
```
Las migraciones se ejecutan en el orden en que fueron creadas, como lo determina el número al inicio de sus nombres de archivo.

Base de datos local
-------------------

Cree una base de datos y mígrela con una versión vacía 1.

    rake db:create
    rake db:migrate

Modelo de datos
---------------

En Rails, el *ActiveRecord* abstrae el acceso a la base de datos.

Cree *app/models/thing.rb*.

``` ruby
class Thing < ActiveRecord::Base
  validates_presence_of :name
  validates_uniqueness_of :name
end
```

Las validaciones son una manera de asegurarse la presencia y la unicidad de los campos. Los campos son generados automáticamente por medio de las consultas al esqueleto al inicio de la aplicación.

El Controlador de la aplicación
-------------------------------

Todos los controladores heredan de `ActionController::Base`. Es una buena idea crear un `ApplicationController` en *app/controllers/application_controller.rb* que pueda implementar una lógica común, tal como la autenticación.

``` ruby
class ApplicationController < ActionController::Base
end
```

El controlador del objeto Thing
-------------------------------

Agregue *app/controllers/things_controller.rb*.

``` ruby
class ThingsController < ApplicationController
end
```

Obteniendo todos los objetos thing para la página index.

``` ruby
def index
  @things = Thing.all
end
```

Obtén un objeto thing existente por medio de un parámetro cuando lo editas o lo muestras. Los hash de `parámetros` poseen entradas a las que pueden accederse por medio de string y símbolos.

``` ruby
def show
  @thing = Thing.find(params[:id])
end
```

Cree un nuevo objeto thing cuando realice un clic en new.

``` ruby
def new
  @thing = Thing.new
end
```

Guarde o actualice un objeto thing cuando realice el envío desde la página de creación o edición. 

``` ruby
def create
  @thing = Thing.new(params[:thing])
  if @thing.save
    redirect_to @thing, notice: 'El objeto Thing ha sido creado con éxito.'
  else
    render action: "new"
  end
end

def update
  @thing = Thing.find(params[:id])
  if @thing.update_attributes(params[:thing])
    redirect_to @thing, notice: 'El objeto Thing ha sido actualizado con éxito.'
  else
    render action: "edit"
  end
end
```

Borre un objeto thing.

``` ruby
def destroy
  @thing = Thing.find(params[:id])
  @thing.destroy
  redirect_to things_url
end
```

Los errores se guardan automáticamente al ser guardado el modelo, el trabajo del controlador es el de refrescar la vista con la correspondiente acción de fallo. Cree *views/shared/_error_msg.html.haml* la cual mostrará el error.

``` haml
- if model.errors.any?
  .error_explanation
    %h3= "#{pluralize(model.errors.count, "error")} saving #{model.class}:"
    %ul
      - model.errors.full_messages.each do |msg|
        %li= msg
```

Los métodos `:index`, `:show`, `:new`, `:edit`, `:update` y `:destroy` son llamados *acciones*. Son los métodos por defecto para el ruteo *RESTful*.

La vista de los objetos Thing
-----------------------------

Agregue *app/views/things/index.html.haml*.

``` haml
%h1 Things

%table
  %tr
    %th= "Name"
    %th
    %th

  - @things.each do |thing|
    %tr
      %td= thing.name
      %td= link_to 'Edit', edit_thing_path(thing)
      %td= link_to 'Destroy', thing, :confirm => "¿Está seguro?", :method => :delete

= link_to "New Thing", new_thing_path
```

En lugar de codificar a mano un formulario, vamos a usar la gema llama [simple_form](https://github.com/plataformatec/simple_form) y realizar una edición de formulario, *app/views/things/_form.html.haml*.

``` haml
= simple_form_for @thing do |f|
  = render 'shared/error_msg', model: @thing
  = f.input :name
  = f.button :submit
```

El formulario puede usarse para los nuevo objeto thing en *app/views/things/new.html.haml*.

``` haml
%h1 New Thing

= render 'form'

= link_to 'Back', things_path
```

También puede utilizarse para editar un objeto thing en *app/views/things/edit.html.haml*.

``` haml
%h1= @thing.name

= render 'form'

= link_to 'Back', things_path
```

Finalmente, debemos mostrar el objeto thing en *app/views/things/show.html.haml*.

``` haml
%ul
  %li= "Name: #{@thing.name}"

= link_to 'Edit', edit_thing_path(@thing)
|
= link_to 'Back', things_path
```

El ruteo de los objetos Thing
-----------------------------

Edite *config/routes.rb*.

``` ruby
RailsMVC::Application.routes.draw do
  resources :things
end
```

Revise `rake routes`.

Links
-----

* [Rails Testing (Inglés)](http://guides.rubyonrails.org/testing.html)

Ejercicios
----------

* Agregue un conjunto de pruebas unitarias al model del objeto Thing que asegure que el objeto es creado, recupérelo por su id, actualícelo y destrúyalo (CRUD):
* Agregue un conjunto de pruebas funcionales para su things_controller que compruebe que el objeto Thing es CRUD.
* Agregue un conjunto de pruebas funcionales para la vista que asegure que muestra una lista de objetos thing por medio de la acción `:index`, formularios para editarlos con `:edit`, el contendido con `:show`, etc.
* Puntos adicionales por pruebas de integración que ejecute un escenario completo de creación, muestreo, edición, actualización y destrucción de objetos Thing.
* Puntos adicionales por pruebas de ruta.
